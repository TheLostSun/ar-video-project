<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AR Video Placement</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  font-family: sans-serif;
  background: black;
  color: white;
  text-align: center;
}

#uiContainer {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10;
}

#startARBtn {
  padding: 18px 30px;
  font-size: 18px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
}

#infoText {
  margin-top: 15px;
  font-size: 14px;
  max-width: 300px;
  line-height: 1.4em;
  opacity: 0.9;
}
</style>
</head>

<body>

<div id="uiContainer">
  <button id="startARBtn">Start AR</button>
  <div id="infoText">
    Hold the phone steady and look towards a flat surface.<br>
    To reset, reload the page.
  </div>
</div>

<script type="module">

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js';

let camera, scene, renderer;
let controller;

let reticle;
let hitTestSource = null;
let viewerSpace = null;

let video, videoTexture, videoMesh;
let placed = false;

const startBtn = document.getElementById("startARBtn");
const uiContainer = document.getElementById("uiContainer");

init();

/* ================= INIT ================= */

function init() {

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera();

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;

  document.body.appendChild(renderer.domElement);

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  // Reticle (UNCHANGED)
  const ringGeo = new THREE.RingGeometry(0.4, 0.5, 32);
  ringGeo.rotateX(-Math.PI / 2);

  const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

  reticle = new THREE.Mesh(ringGeo, ringMat);
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;

  scene.add(reticle);

  renderer.setAnimationLoop(render);

  startBtn.onclick = startAR;
}

/* ================= START AR ================= */

async function startAR() {

  const session = await navigator.xr.requestSession('immersive-ar', {
    requiredFeatures: ['hit-test']
  });

  renderer.xr.setReferenceSpaceType('local');
  await renderer.xr.setSession(session);

  // FAST hit-test initialization
  viewerSpace = await session.requestReferenceSpace('viewer');
  hitTestSource = await session.requestHitTestSource({
    space: viewerSpace
  });

  session.addEventListener('end', () => {
    hitTestSource = null;
    viewerSpace = null;
  });

  // Remove UI
  uiContainer.remove();
}

/* ================= PLACE VIDEO ================= */

function onSelect() {

  if (!placed && reticle.visible) {

    const geometry = new THREE.PlaneGeometry(3.2, 1.8);


    video = document.createElement("video");
    video.src = "video.mp4";
    video.loop = true;
    video.muted = true;
    video.playsInline = true;
    video.play();

    videoTexture = new THREE.VideoTexture(video);
    videoTexture.colorSpace = THREE.SRGBColorSpace;

    const material = new THREE.MeshBasicMaterial({
      map: videoTexture,
      side: THREE.DoubleSide
    });

    videoMesh = new THREE.Mesh(geometry, material);

    // Keep your original placement behavior
    videoMesh.position.setFromMatrixPosition(reticle.matrix);
    videoMesh.lookAt(camera.position);

    scene.add(videoMesh);

    placed = true;
    reticle.visible = false;
  }
}

/* ================= RENDER ================= */

function render(timestamp, frame) {

  if (frame && hitTestSource && !placed) {

    const referenceSpace = renderer.xr.getReferenceSpace();
    const hitTestResults = frame.getHitTestResults(hitTestSource);

    if (hitTestResults.length > 0) {

      const hit = hitTestResults[0];
      const pose = hit.getPose(referenceSpace);

      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);

    } else {
      reticle.visible = false;
    }
  }

  renderer.render(scene, camera);
}

</script>

</body>
</html>
